<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DevOps on Analytics &amp; Modeling Blog</title>
    <link>/blog/tags/devops/</link>
    <description>Recent content in DevOps on Analytics &amp; Modeling Blog</description>
    <image>
      <title>Analytics &amp; Modeling Blog</title>
      <url>/blog/images/analytics-blog-cover.png</url>
      <link>/blog/images/analytics-blog-cover.png</link>
    </image>
    <generator>Hugo -- 0.125.7</generator>
    <language>en</language>
    <copyright>2025 Trevor Jordan</copyright>
    <lastBuildDate>Sat, 11 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/blog/tags/devops/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Real-time Anomaly Detection: Catching Infrastructure Issues Before Users Do</title>
      <link>/blog/posts/20250111-anomaly-detection/</link>
      <pubDate>Sat, 11 Jan 2025 00:00:00 +0000</pubDate>
      <guid>/blog/posts/20250111-anomaly-detection/</guid>
      <description>The 3 AM Wake-up Call It was 3 AM when my phone buzzed with an urgent alert: our main API endpoint was experiencing unusual latency spikes. But here&amp;rsquo;s the twist - our newly implemented anomaly detection system caught this before any user reported issues. By the time I checked the dashboard, our automated remediation had already scaled up the necessary resources.
Why Traditional Monitoring Falls Short Traditional monitoring relies heavily on static thresholds.</description>
    </item>
  </channel>
</rss>
